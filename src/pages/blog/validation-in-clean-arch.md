---
templateKey: blog-post
title: Clean Architectureにおいて、バリデーションはどこでやるべきか
date: "2019-03-20T00:00Z"
thumbnail: "./hoge.png"
lang: ja
---

クリーンアーキテクチャで web アプリケーションを作る際に、バリデーションはどのレイヤの責務なのか？と悩むことが多いため、それについての考察を行ってみる。

あと、バリデーションについて書いてたはずがドメインロジックとアプリケーションロジックの違いについても結構言及することになったので、そのへんの話もしてみる。

## 結論から言うと

**バリデーションはどのレイヤの責務なのか？という問い自体が間違いであり、レイヤごとにそのレイヤの責務となるバリデーションを行うべき、というのが今のところの結論。**

バリデーションという単語は意味があまりに広い。「意図していないもの/ことを防ぐ」ことはすべてバリデーションと呼ばれている節がある。
そのことにより、バリデーションというのはあたかも唯一つの責務であるかのように錯覚しがちだが、そうではない。クリーンアーキテクチャではレイヤによって責務を分担しているが、同様にバリデーションについても、**それぞれのレイヤごとに、それを受け付けてしまうと自分のレイヤの責務を果たすことができなってしまうような input がやってきた場合は弾くようにする、というのがバリデーションである。** なので、バリデーションはレイヤごとに存在するし、バリデーションの責務や意味合いはレイヤごとに異なる。

そして逆に言うと、**とあるレイヤで、そのレイヤの責務以上のバリデーションをしてしまうようなお節介をすべきではない。**後述するが、そのようなことをすると何らかの不都合が発生してしまう。

### バリデーションは単なる仕様

バリデーションという言葉に引っ張られて、クリーンアーキテクチャの枠から外れてバリデーションを特別扱いして考えてしまってはいけない。**バリデーションも単なる仕様に過ぎない。仕様の部分集合をわざわざバリデーションと呼んでいるだけである。**  
「ユーザーは JSON 形式でリクエストできる」「ユーザーは任意の文章を投稿できる」といった仕様があればまた、その裏返しとして「JSON 以外の形式は受け付けない」「本文が空白の場合は投稿できない」といった仕様もあるというだけの話である。
**システムが、自身に言いつけられた仕様や責務を果たそうと努力した結果の副産物としてバリデーションが発生する。**

ここまでで核心的なお話は終わってしまった感があるが、ここから先は、具体的にクリーンアーキテクチャにおいてどの層でどういったバリデーションをすべきかについて考察していく。

## Frameworks & Drivers 層におけるバリデーション

この層はクリーンアーキテクチャにおいて一番外側に位置する層であり、自分たちで実装する分量は少ないが、この層でもバリデーションが行われる場合がある。

たとえば HTTP 通信において、リクエストのデータが大きすぎる場合は HTTP Status Code として 413(Entity Too Large)を返す場合があるが、これも一種のバリデーションと言える。
あとは、SSL/TLS におけるリクエストの改竄チェックとかもバリデーションと言っていいのかもしれない。
このレイヤにおけるバリデーションは、低レイヤにおける最低限のセキュリティの担保というのが主な役割になりそう。

## Interface Adapter 層におけるバリデーション

Interface Adapter の責務は、アプリの内外のデータ形式の変換である。
たとえば、外部から渡ってきた HTTP Request の Body に入っている JSON 文字列を、辞書型のオブジェクトなどにデシリアライズして適切な UseCase に渡す、といった処理である。

ここで、たとえば Request Body が壊れており JSON のフォーマットになっていない場合などは、内外のデータの変換が完遂できないのでエラーとするのが一般的であると思うが、これも一種のバリデーションエラーといえる。やりとりのためのプロトコルが守られていないことを検知して弾いていることになるので、立派なバリデーションエラーである。**Interface Adapter 層におけるバリデーションは、「データ変換のためのプロトコルが守られているかのチェック」であるといえる。**

逆に、正しくオブジェクトにデシリアライズできたのであれば、Interface Adapter 層ではそれ以上のチェック、たとえば文字数や数値範囲のチェックは不要である。なぜならそれをやると、内外のデータ形式の変換という役割から逸脱してしまうからである。

ここでたとえばおせっかいをして、文字数のチェックまで行ってしまったとする。

TBW

## Application 層[^1]と Domain 層[^2]それぞれにおけるバリデーション

[^1]原典では Application Business Rules 層と呼ばれている
[^2]原典では Enterprise Business Rules 層と呼ばれている

Application 層にはアプリケーションロジックが書かれ、Domain 層にはドメインロジックが書かれる。

ところで、アプリケーションロジックとドメインロジックの違いは？という問いについては、単純明快かつ直感的でツッコミどころがない表現による回答は難しいという問題があるため、ここでは一旦以下のような定義として話を進めさせてもらう。

- **アプリケーションロジック**: それが無くても、対象のドメインや概念に影響は無いロジック。

- **ドメインロジック**: それが無いと、対象のドメインや概念が成り立たなくなるようなロジック。

具体例で考えてみる。以下のようなバリデーションについて考える。

```txt
1. ECサイトにおいて、入力ミスによる大量発注を防ぐため、注文できる上限個数は99個とする。
```

これはアプリケーションロジックと言える。  
上限個数を設けることが EC サイトという概念に必須なのかというとそうではない。別に上限個数がなくても EC サイトとしては機能する。ここでの 99 個という上限は、ユーザー体験を損なわないためにとりあえず設定しているだけである。
なのでこれはアプリケーションロジックだし、Application 層に書くべきであるといえる。

では次はどうだろうか。

```txt
2. ECサイトにおいて、1人あたりの購入上限個数が決まっている限定セールを行う際、一人が注文できる上限個数は3個とする。
```

これはドメインロジックと言える。  
このバリデーションがなかった場合には限定セールという概念自体が成り立たなくなるためである。ドメインロジックなので、Domain 層に書くべきであると言える。

※ なお、アプリケーションロジックなのかドメインロジックなのかは、「そもそも何をドメインとするか」で変わってくる可能性があることは注意。このへんの性質が、両者の違いをはっきり言語化できない原因のような気がする。。

上記 2 つの例を見ると分かる通り、ややこしいのは、**入力数値のバリデーションひとつ取っても、アプリケーションロジックになる場合もあるしドメインロジックになる場合もある**という点である。  
文面的には両者はほぼほぼ変わらないため、この事実は見落とされやすい。そのため、とあるバリデーションについて Application 層に書くべきなのか Domain 層に書くべきなのかの見極めは慎重に行う必要がある。

#### 余談

twitter の 140 字制限は果たしてどっちなんだろうか。どっちかというとアプリケーションロジック寄りな気もするが、文字数制限が厳し目なのが twitter という概念の根幹な気もするので、ドメインロジックな気もする。やっぱりアプリケーションロジックとドメインロジックの明確な境目を一言でバシッと定めるのは難しい。。

ちょっと脱線したが話を戻していく。

## バリデーションを書く場所を間違うとどうなるか

ここまで、各層においてどんなバリデーションをすべきかについて述べてきたが、では、とある層がお節介をしてしまい他の層でやるべきバリデーションまでやってしまうとどうなるのか考えてみる。

### ドメイン層でやるべきバリデーションをアプリケーション層でやってしまった場合

この層にはドメインロジックが書かれる。

ここでたとえば、先程アプリケーション層におけるバリデーションの例としてあげた、「一応の上限として書き込みの際の文字数は 1000 文字までとしておく」というのをドメイン層に書いていたらどうなっていたかについて考えてみる。

最初のうちは問題にならないかもしれないが、もしあとで、「やっぱり 500 文字に制限をきつくしよう」としたときに何が起きるだろうか。  
既存の投稿を DB から取り出し、ドメイン層のオブジェクト(クリーンアーキテクチャだとエンティティ)として復元しようとしたときに、500 文字を超えている既存の投稿についてはオブジェクト生成時のバリデーションに引っかかってエラーになり、復元できなくなってしまう、といったケースが考えられる。

これは本来アプリケーション層にあるべきロジックをドメイン層に書いてしまったがゆえに起こってしまった事象であると言える。もしアプリケーション層に書いていれば、バリデーションが走るのは投稿時のみに限るようにすることができ、既存の投稿には一切影響を与えずに新規の投稿についてのみ文字数制限を厳しくすることができたはずである。  
文章の文字数制限は、投稿サイトにおいてはドメインロジックではなかったということだ。

## まとめ

こうしてみると、どの層も責務は違えど、自分の責務を果たそうとした結果としてバリデーションが発生していることがわかって、当たり前といえばそうではあるけど面白い。

意識的にバリデーションを書こうとするのではなく、各レイヤに適切な責務を持たせようとした結果として自然とバリデーションロジックが書かれるような設計実装の方針が理想と言えそうです。
