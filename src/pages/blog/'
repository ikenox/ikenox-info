---
templateKey: blog-post
title: Clean Architectureにおいて、バリデーションはどこでやるべきか
date: "2019-03-20T00:00Z"
thumbnail: "./hoge.png"
lang: ja
---

クリーンアーキテクチャでwebアプリケーションを作る際に、バリデーションはどのレイヤの責務なのか？と悩むことが多いため、それについての考察を行ってみる。

あと、バリデーションについて書いてたはずがドメインロジックとアプリケーションロジックの違いについても結構言及することになったので、そのへんの話もしてみる。

## 結論から言うと

**バリデーションはどのレイヤの責務なのか？という問い自体が間違いであり、レイヤごとにそのレイヤの責務となるバリデーションを行うべき、というのが今のところの結論。**

バリデーションという単語は意味があまりに広い。「意図していないもの/ことを防ぐ」ことはすべてバリデーションと呼ばれている節がある。
そのことにより、バリデーションというのはあたかも唯一つの責務であるかのように錯覚しがちだが、そうではない。クリーンアーキテクチャではレイヤによって責務を分担しているが、同様にバリデーションについても、**それぞれのレイヤごとに、それを受け付けてしまうと自分のレイヤの責務を果たすことができなってしまうようなinputがやってきた場合は弾くようにする、というのがバリデーションである。** なので、バリデーションはレイヤごとに存在するし、バリデーションの責務や意味合いはレイヤごとに異なる。

そして逆に言うと、**とあるレイヤで、そのレイヤの責務以上のバリデーションをしてしまうようなお節介をすべきではない。**後述するが、そのようなことをすると何らかの不都合が発生してしまう。

バリデーションという言葉に引っ張られて、クリーンアーキテクチャの枠から外れてバリデーションを特別扱いして考えてしまってはいけない。**バリデーションも単なる仕様に過ぎない。仕様の部分集合をわざわざバリデーションと呼んでいるだけである。**  
「ユーザーはJSON形式でリクエストできる」「ユーザーは任意の文章を投稿できる」といった仕様があればまた、その裏返しとして「JSON以外の形式は受け付けない」「本文が空白の場合は投稿できない」といった仕様もあるというだけの話である。
**システムが、自身に言いつけられた仕様や責務を果たそうと努力した結果の副産物としてバリデーションが発生する。**

## Interface Adapter層におけるバリデーション

Interface Adapterの責務は、アプリの内外のデータ形式の変換である。
たとえば、外部から渡ってきたHTTP RequestのBodyに入っているJSON文字列を、辞書型のオブジェクトなどにデシリアライズして適切なUseCaseに渡す、といった処理である。

ここで、たとえばRequest Bodyが壊れておりJSONのフォーマットになっていない場合などは、内外のデータの変換が完遂できないのでエラーとするのが一般的であると思うが、これも一種のバリデーションエラーといえる。やりとりのためのプロトコルが守られていないことを検知して弾いていることになるので、立派なバリデーションエラーである。**Interface Adapter層におけるバリデーションは、「データ変換のためのプロトコルが守られているかのチェック」であるといえる。**

逆に、正しくオブジェクトにデシリアライズできたのであれば、Interface Adapter層ではそれ以上のチェック、たとえば文字数や数値範囲のチェックは不要である。なぜならそれをやると、内外のデータ形式の変換という役割から逸脱してしまうからである。

ここでたとえばおせっかいをして、文字数のチェックまで行ってしまったとする。

TBW

## UseCase層(Application Business Rules層)におけるバリデーション

この層はいわゆるアプリケーションロジックが書かれる層である。
ところで、アプリケーションロジックとは？ドメインロジックとの違いは？という問いについて単純明快かつ直感的でツッコミどころがない表現による回答が難しいという問題があるので、ここでは一旦以下のような定義として話を進めさせてもらう。

- **アプリケーションロジック**: それが無くても、対象のドメインや概念に影響は無いロジック。

- **ドメインロジック**: それが無いと、対象のドメインや概念が成り立たなくなるようなロジック。  

具体例で考えてみる。以下のような仕様について考える。

```txt
1. ECサイトにおける、「入力ミスによる大量発注を防ぐため、注文できる上限個数は99個とする」という仕様
```

これはアプリケーションロジックといえる。  
上限個数が99個であることが文章投稿サイトという概念に必須なのかというとそうではない。べつに100個でも9999999999999個でもいいし、なんなら制限が無くてもECサイトとして成り立つことには変わりはない。  
この1000文字というのは、システムの処理能力やフロントエンドでの表示形式を考慮し、UXを損なわないラインとしてひとまず設定しているだけである。
なのでこれはアプリケーションロジックだし、UseCase層でバリデーションを行うべきであるといえる。


もしこの仕様が無かったとしても特にECという概念は成り立つため、
たとえばECサイトにおいて、一人あたりの購入上限個数が決まっている限定セールを行うために、「一人が注文できる上限個数は3個とする」という仕様があったとして、もしこの仕様がなかった場合には限定セールという概念が成り立たなくなるため、これはドメインロジックといえる。

※ アプリケーションロジックなのかドメインロジックなのかは、「そもそも何をドメインとするか」で変わってくる可能性があることは注意。このへんが両者の違いが分かりづらくなる原因っぽい気がする。。

ここで難しいのが、上記2つの例を見ると分かる通り、**入力数値のバリデーションひとつ取っても、アプリケーションロジックである場合もあるしドメインロジックである場合もある**という点である。
そのため、とあるバリデーションについて、UseCase層に書くべきなのかDomain層に書くべきなのかの見極めは慎重に行う必要がある。

どういうことかについてもう少し詳しく説明する。たとえば以下の仕様について考える。

```txt
1. 文章投稿サイトにて、悪意あるユーザーに無駄な長文を投稿されるのは避けたいので、一応の上限として書き込みの際の文字数は1000文字までとしておく
```


ここでたとえばおせっかいをして、本来ドメイン層ですべきバリデーションまでアプリケーション層でやってしまうとどうなるのか。

## Domain層(Enterprise Business Rules層)におけるバリデーション

この層にはドメインロジックが書かれる。

```txt
2. 何分後
```

これはドメインに書くべき。


ここでたとえば、先程アプリケーション層におけるバリデーションの例としてあげた、「一応の上限として書き込みの際の文字数は1000文字までとしておく」というのをドメイン層に書いていたらどうなっていたかについて考えてみる。

最初のうちは問題にならないかもしれないが、もしあとで、「やっぱり500文字に制限をきつくしよう」としたときに何が起きるだろうか。  
既存の投稿をDBから取り出し、ドメイン層のオブジェクト(クリーンアーキテクチャだとエンティティ)として復元しようとしたときに、500文字を超えている既存の投稿についてはオブジェクト生成時のバリデーションに引っかかってエラーになり、復元できなくなってしまう、といったケースが考えられる。  

これは本来アプリケーション層にあるべきロジックをドメイン層に書いてしまったがゆえに起こってしまった事象であると言える。もしアプリケーション層に書いていれば、バリデーションが走るのは投稿時のみに限るようにすることができ、既存の投稿には一切影響を与えずに新規の投稿についてのみ文字数制限を厳しくすることができたはずである。  
文章の文字数制限は、投稿サイトにおいてはドメインロジックではなかったということだ。

#### 余談

ここまで書いてて、UXを意識した仕様は基本的にアプリケーションロジックな気がしてきた。逆に、UXとか関係なく、根幹すぎて変更しようがないものはドメインロジックかも。

と思ったが、twitterの140字制限は果たしてどっちなんだろうか。どっちかというとアプリケーションロジック寄りな気もするが、140字というのがtwitterという概念の根幹な気もする。けど、UXが最適化されたマイクロブログがtwitterであるという考え方だと、140字というのも必須ではないし、やっぱりアプリケーションロジックかな。という感じで、やっぱりアプリケーションロジックとドメインロジックの明確な境目を一言でバシッと定めるのは難しい。。

ちょっと脱線したが話を戻していく。

## Frameworks & Drivers層におけるバリデーション

この層はクリーンアーキテクチャにおいて一番外側に位置する層であり、自分たちで実装する分量は少ないが、この層でもバリデーションが行われる場合がある。

たとえばHTTP通信において、リクエストのデータが大きすぎる場合はHTTP Status Codeとして413(Entity Too Large)を返す場合があるが、これも一種のバリデーションと言える。
あとは、SSL/TLSにおけるリクエストの改竄チェックとかもバリデーションと言っていいのかもしれない。
このレイヤにおけるバリデーションは、低レイヤにおける最低限のセキュリティの担保というのが主な役割になりそう。

## まとめ

こうしてみると、どの層も責務は違えど、自分の責務を果たそうとした結果としてバリデーションが発生していることがわかって、当たり前といえばそうではあるけど面白い。

意識的にバリデーションを書こうとするのではなく、各レイヤに適切な責務を持たせようとした結果として自然とバリデーションロジックが書かれるような設計実装の方針が理想と言えそうです。
